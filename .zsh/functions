REPOS_DIR=$HOME/pg

session () {
    SESSIONS=$(tmux list-sessions -F "#{session_name}")
    SELECTED_SESSION=$(echo "$SESSIONS" | fzf)

    if [[ -n "$SELECTED_SESSION" ]]; then
        tmux switch -t $SELECTED_SESSION
    fi
}

repo () {
    REPOS=$(find $REPOS_DIR -type d -exec test -d '{}/.git' \; -prune -print;)
    SELECTED_REPO=$(echo "$REPOS" | sed "s,$REPOS_DIR/,," | fzf)
    if [[ -n "$SELECTED_REPO" ]]; then
        cd "$REPOS_DIR/$SELECTED_REPO"
    fi
}

function containsElement() {
    # Usage: containsElement <retval> "<search_string>" "${array[@]}"
    # Returns true if array contains <search_string>

    local e
    for e in "${@:3}"; do
        if [[ "$e" == "$2" ]]; then
            eval $1=true
            return
        fi
    done
    eval $1=false
}

function tmuxpg() {
    agenttmux2 attach-session -t pg || agenttmux2 new-session -s pg
    PROMPT_COMMAND='eval `/nail/scripts/tmux-env`'
}

function clean_all_branches () {
    git checkout master;
    git fetch;
    git reset --hard origin/master;
    git branch --merged | tr -d ' ' | sed -e 's/^\*//' | grep -v 'master' | while read branch; do
        git branch -d $branch && git push origin :$branch;
    done
}


### Save and restore branch state automatically when switching branches

# Usage: item_in_array x x y z (first x is query item)
item_in_array() {
  local arr_item query="$1"
  shift
  for arr_item in "$@"; do
  [[ "$arr_item" == "$query" ]] && return 0
  done
  return 1
}
is_clean_git_directory() {
  local num_dirty=$(expr $(git status --porcelain 2>/dev/null | grep -e "^(M| M)" | wc -l))
  local num_untracked=$(expr `git status --porcelain 2>/dev/null| grep "^??" | wc -l`)
  local total_changed=$((num_dirty + num_untracked))
  return $total_changed
}
git_branch_state_decorator() {
  # Use this internally otherwise the function will be called recursively
  local system_git="/usr/bin/git"
  local save_prefix="[[save state]]"
  local cmd="$1"
  # Without (...), a $@ would be auto-quoted for multiple params
  local original_args=($@)
  shift
  local cmd_args=($@)
  # Update with any custom git aliases for checkout ("co" is an example)
  local checkout_cmds=("checkout" "co")
  local exit_status

  # Filter anything other than checkout, without -b
  if ! item_in_array "$cmd" "${checkout_cmds[@]}"; then
    $system_git $original_args
    return $?
  fi
  if item_in_array "-b" "${cmd_args[@]}"; then
    $system_git $original_args
    return $?
  fi
  # Ignore "checkout ."
  if item_in_array "." "${cmd_args[@]}"; then
    $system_git $original_args
    return $?
  fi

  # Make a commit of working changes with special name
  $system_git add .
  $system_git commit -m "${save_prefix} branch: $($system_git rev-parse --abbrev-ref HEAD)" 1>/dev/null
  # Why not just check error code? Running a commit on a clean working
  # directory has a non-zero exit code
  if ! is_clean_git_directory; then
    echo "[Branch state save failed]"
    return 1
  fi

  # Switch to new branch
  $system_git $original_args
  exit_status=$?
  if [[ $exit_status -ne 0 ]]; then
    echo "[Branch switch failed]"
    return $exit_status
  fi

  # Check for existing stash commit and do mixed reset
  local latest_commit_msg=$($system_git log -1 --oneline)
  if [[ "$latest_commit_msg" =~ "$save_prefix" ]]; then
    $system_git reset HEAD^1 1>/dev/null
  fi
  exit_status=$?
  if [[ $exit_status -ne 0 ]]; then
    echo "[Branch state restore failed]"
  fi
  return $exit_status
}
